# Day1

-- 创建WEB - TESK MANGER项目文件夹

-- 在wtm下创建backend文件夹，在终端运行: `npm init -y` 

> `npm init -y` 的完整意思就是：“Node包管理器，请立刻以默认配置为我初始化一个新项目，生成`package.json`文件

>npm init -y 解释：
>
>```json
>  "name": "backend",
>  "version": "1.0.0",
>  "main": "index.js",
>  "scripts": {
>    "test": "echo \"Error: no test specified\" && exit 1"
>  },
>  "keywords": [],
>  "author": "",
>  "license": "ISC",
>  "description": ""
>```
>
>在编程世界里，这些“材料”就是别人已经写好的、可复用的代码库（比如我们后面要用的 `Express`, `React` 等）。
>
>这么多材料，我们需要一个**清单**来管理它们：
>
>- 项目叫什么名字？（项目名）
>- 现在是第几版？（版本号）
>- 项目的“正门”是哪个文件？（入口文件）
>- 项目需要哪些“核心材料”？（项目依赖）
>- 有没有一些快捷“操作指令”？（例如一键启动项目）
>
>这个清单，就是我们刚刚创建的 `package.json` 文件。**它就是我们Node.js项目的“身份证”和“配置文件”，是整个项目的核心。**
>
>指令解释：
>`npm`: **N**ode **P**ackage **M**anager (Node包管理器) -- 调包侠的库
>
>`init`: “初始化”。这个指令告诉 `npm`：“嘿，我要在这里启动一个全新的项目，请帮我生成那个核心的配置文件。”
>
>`-y`: 这是一个**参数**，是 `--yes` 的简写。加上 `-y` 就等于你对它说：“别问了，所有问题都用默认答案就行！赶紧给我办好！” (否则：一步一步问你问题：“你的项目叫什么名字？”、“版本号是多少？”、“作者是谁？”...等等)
>
>`npm init -y` 的完整意思就是：“Node包管理器，请立刻以默认配置为我初始化一个新项目，生成`package.json`文件

```json
我们来逐行解读一下这个“身份证”上的信息：

"name": "backend": 项目名称。npm init -y 默认使用了你所在的文件夹的名字 backend 作为项目名。

"version": "1.0.0": 项目版本号。通常遵循“主版本号.次版本号.修订号”的格式。

"main": "index.js": 项目入口文件。它告诉Node.js，当启动这个项目时，应该先去执行 index.js 这个文件。这是非常重要的一个配置。

"scripts": { ... }: 脚本命令。这是一个非常强大的功能！它允许我们定义一些快捷命令。比如现在里面有一个 "test": ...，意思是当你在终端运行 npm test 时，它就会去执行冒号后面的那段指令。我们很快就会在这里添加自己的启动命令，比如 "start": "node index.js"，之后我们就可以用 npm start 来启动服务器，而不是每次都输入 node index.js。

"keywords": []: 关键词。如果要把你的项目发布到npm市场上，这里的关键词可以帮助别人搜索到它。我们自己开发用不上。

"author": "" / "license": "ISC" / "description": "": 作者、许可证、项目描述。这些都是项目的说明性信息。
```



-- 在终端输入：`npm install express mongoose bcryptjs jsonwebtoken dotenv cors`

> ```json
> express: [核心框架] 这是Node.js世界里最流行、最简单的Web服务器框架。你可以把它想象成大楼的“主体钢结构”，我们所有的API接口（路由）都将基于它来搭建。
> 
> mongoose: [数据库桥梁] 我们的数据存放在MongoDB数据库里。mongoose 是一个能让我们用JavaScript代码非常方便地去操作MongoDB的工具。它就像是连接我们应用和数据库之间的“管道和阀门”。
> 
> bcryptjs: [密码保安] 用户的密码绝对不能以明文（比如 "123456"）的形式直接存到数据库里，这是极不安全的。bcryptjs 这个库可以帮我们把用户的密码进行加密处理，变成一长串谁也看不懂的乱码，然后再存入数据库，极大地提升了安全性。
> 
> jsonwebtoken: [身份通行证] 简称 JWT。当用户登录成功后，我们的服务器会生成一个加密的“令牌”（Token），就像一张有时效性的“通行证”，然后发给用户。之后用户每次请求需要权限的API时，都必须带上这张“通行证”，服务器验证通过后，才知道“哦，这是自己人”，才会返回数据给他。这就是用户认证（Authentication）的核心。
> 
> dotenv: [机密文件柜] 在项目中，我们会有一些敏感信息，比如数据库的连接地址、JWT的加密密钥等。这些信息不能直接写在代码里，否则上传到GitHub后所有人都能看到。dotenv 能让我们把这些敏感信息写在一个特殊的 .env 文件里，然后在代码中安全地读取它们。这个 .env 文件我们之后会告诉Git不要上传，从而保护了我们的机密。
> 
> cors: [跨域通行许可] 出于安全考虑，浏览器默认禁止网页去请求一个和它本身来源不同的地址（比如 [可疑链接已删除] 的网页不能直接请求 b.com 的API）。我们的前端（未来会运行在比如 localhost:3000）和后端（现在运行在 localhost:5001）是分开的，这就会产生“跨域”问题。cors 这个库就像是给我们的后端服务器办了一张“跨域许可”，告诉浏览器：“别担心，我允许来自其他地方的请求”，这样我们的前后端才能正常通信。
> ```
>
> 1. 安装完成后， `backend` 文件夹下多了两个东西：
>
> **`node_modules` 文件夹**: 所有下载的第三方库, **永远不需要手动修改这个文件夹里的任何东西**，它完全由 `npm` 自动管理。
>
> **`package-lock.json` 文件**: 这个文件是 `npm` 自动生成的，它会精确记录下当前安装的每一个包的**确切版本号**和它们的依赖关系。它的作用是保证其他开发者或者服务器在运行 `npm install` 时，能和本地安装完全一模一样的版本
>
> 2. `package.json` 的变化
>
> 现在再打开 `package.json` 文件，多了一个 `"dependencies"` 字段
>
> ```json
> "dependencies": {
>   "bcryptjs": "^2.4.3",
>   "cors": "^2.8.5",
>   "dotenv": "^16.0.3",
>   "express": "^4.18.2",
>   "jsonwebtoken": "^9.0.0",
>   "mongoose": "^7.0.3"
> }
> ```
>
> `npm install` 会自动把刚刚安装的这些库的名字和版本号记录到项目的“身份证”上。这就是“依赖清单”。现在，任何人拿到项目，只需要运行 `npm install`，`npm` 就会看着这个清单，把所有需要的库全部下载下来。



第二步：创建第一个Express服务器

1. 创建服务器入口

-- 在 `backend` 文件夹的根目录下（和`package.json`平级），创建一个新文件，命名为 `index.js`

> 这是我们整个后端应用的“正门”和“总开关”, package.json文件里有的，main入口

2. 编写最简单的服务器代码

-- 打开index.js` 文件，然后把下面的代码复制进去：

```json
// 1. 引入我们安装的 express 包
const express = require('express');

// 2. 创建一个 express 应用实例
const app = express();

// 3. 定义一个端口号，我们的服务器将在这个端口上运行
const PORT = 5001;

// 4. 创建一个最简单的路由（Route）
// 当有人访问我们网站的根路径（'/'）时，我们返回一段文字
app.get('/', (req, res) => {
    res.send('Hello, Task Manager API is running!');
});

// 5. 启动服务器，并让它监听我们定义的端口
app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
});
```

> **代码解释：**
>
> - `require('express')`: 这是Node.js的模块导入语法，意思是“去`node_modules`文件夹里，找到`express`这个库，然后把它引进来”，并赋值给 `express` 这个常量。
>
> - `const app = express()`: 我们通过执行`express()`函数，创建了一个Express应用的实例。你可以把 `app` 这个变量想象成我们整个Web应用的总管。
>
>   > `app` 和 `express` 确实是两个东西，我们操作 `app` 不会污染 `express`。
>   >
>   > 但从**技术实现**的角度看，它不完全是“拷贝”，而更像是**“创建”或“实例化”**。
>   >
>   > **`express` 是模板/类**：我们 `require('express')` 得到的这个 `express` 对象，就可以被理解为那个**“模板”或者“类定义”**。它本身不是一个能直接提供服务的Web应用，而是定义了一个Web应用应该**是什么样子的**、**拥有哪些能力**（比如 `.get()`, `.listen()` 等）。它就是那个蓝图。
>   >
>   > **`app` 是实例**：`const app = express()` 就是**实例化**这个模板的过程。我们根据这个蓝图，建造出了一个具体的、可以装修和使用的房子 `app`。
>
> - `app.get(...)` 和 `app.listen(...)` 的细节
>
>   你感觉到了，这两行代码里包含了一个对新手来说最难理解，但也是JavaScript中最重要的概念之一：**回调函数 (Callback Function)**。
>
>   我们来拆解 `app.get('/', (req, res) => { ... });`
>
>   - `app.get()`: `.get` 是 `app` 对象的一个**方法**（也就是隶属于这个对象的一个函数）。这个方法的作用是：**注册一个路由规则**。它告诉Express：“请听好，我现在要给你定一条规矩。”
>   - `'/'`: 这是这条规矩的**第一个参数**：路径。它告诉Express：“这条规矩只在有人访问网站**根目录**的时候生效。”
>   - `(req, res) => { ... }`: 这是这条规矩的**第二个参数**，也是最核心的部分。它是一个**函数**。但它不是立即执行的，而是被“注册”给 `.get` 方法。这种“**我现在定义好，你将来在某个特定时机再去调用**”的函数，就叫做**回调函数**。
>     - **何时调用？** Express会在每次接到一个访问根目录的GET请求时，**回头来调用**我们传给它的这个函数。
>     - **`(req, res)` 是什么？** 当Express调用这个函数时，它会非常贴心地准备好两个“包裹”作为参数传进来。第一个包裹叫 `req` (Request)，里面装着所有关于这次请求的信息（比如谁在访问，从哪个IP地址来的等等）。第二个包裹叫 `res` (Response)，这是一个工具箱，里面有很多方法可以让你构建即将发送回去的响应。
>     - `=> { res.send('...'); }`: 这是ES6箭头函数的写法，是 `function(req, res) { ... }` 的简写。花括号 `{}` 里面就是函数的具体内容。`res.send('...')` 的意思就是：“使用响应工具箱 `res` 里的 `send` 方法，把这段文字发送给发起请求的客户端（浏览器）。”
>
>   **总结 `app.get`:** 这行代码的意思是：“嗨，`app`总管，请记下一个规则：将来，无论何时，只要有人用GET方式访问网站根目录，你就立刻执行我交给你的这个函数，并且把请求信息(req)和响应工具(res)都准备好传给它。”
>
>   ------
>
>   现在拆解 `app.listen(PORT, () => { ... });`
>
>   - `app.listen()`: 这是 `app` 对象的另一个**方法**，它的作用是**启动服务器**。
>   - `PORT`: 这是**第一个参数**：端口号。它告诉服务器：“请在 `5001` 这个端口号上安家，并开始监听来自这个端口的任何网络请求。”
>   - `() => { console.log(...) }`: 这又是**一个回调函数**！
>     - **何时调用？** `.listen` 方法在成功启动服务器、一切准备就绪之后，会**回头来调用**这个函数，**并且只调用一次**。
>     - `console.log(...)`: 这个函数的内容很简单，就是在我们的终端里打印一句话。它的作用就是给我们一个明确的信号：“报告！服务器已成功启动，随时待命！” 如果没有这个回调函数，服务器虽然也启动了，但我们在终端里就看不到任何提示，就不知道它到底成功了没有。



3. 启动你的第一个服务器！

-- 在终端运行 `node index.js`

> 按下回车，如果一切顺利，你应该会在终端里看到我们写的那句话： `Server is running on port 5001`



4. 验证服务器是否工作

-- 打开你的网页浏览器（比如Chrome或Edge），在地址栏输入以下地址，然后访问：

```
http://localhost:5001
```

> 你应该能在浏览器页面上看到我们设置的返回信息： `Hello, Task Manager API is running!`



5. 引入 `dotenv` 管理配置

> 回顾：dotenv: [机密文件柜] 在项目中，我们会有一些敏感信息，比如数据库的连接地址、JWT的加密密钥等。这些信息不能直接写在代码里，否则上传到GitHub后所有人都能看到。dotenv 能让我们把这些敏感信息写在一个特殊的 .env 文件里，然后在代码中安全地读取它们。这个 .env 文件我们之后会告诉Git不要上传，从而保护了我们的机密。

1. -- **创建 `.env` 文件**: 在`backend`文件夹的根目录下（和`index.js`平级），再创建一个新文件，文件名就是 `.env`。

2. -- **在 `.env` 文件中定义端口**: 打开 `.env` 文件，写入下面这行内容：

   ```
   PORT=5001
   ```

3. -- **修改 `index.js` 来使用 `.env` 文件**: 现在，我们修改 `index.js`，让它能够读取 `.env` 文件里的配置。

   JavaScript

   ```
   const express = require('express');
   const dotenv = require('dotenv'); // 1. 引入 dotenv
   
   dotenv.config(); // 2. 加载 .env 文件中的配置
   
   const app = express();
   
   // 3. 从 process.env 中读取端口号，如果 .env 文件里没有，就默认使用 5000
   const PORT = process.env.PORT || 5000;
   
   app.get('/', (req, res) => {
       res.send('Hello, Task Manager API is running!');
   });
   
   app.listen(PORT, () => {
       console.log(`Server is running on port ${PORT}`);
   });
   ```

**再次启动和验证：**

- 在终端里，按 `Ctrl + C` 来停止之前正在运行的服务器。
- 再次运行 `node index.js`。
- 你应该会看到同样的启动信息，并且在浏览器中访问 `http://localhost:5001` 依然有效。



**！！！注意：必须先 `node index.js` 才能访问浏览器**

> 原因在于 **客户端-服务器 (Client-Server) 模型**。
>
> 1. **服务器 (Server)**:
>    - `node index.js` 这个命令，就是用Node.js环境来**执行**你的 `index.js` 脚本。
>    - 这个脚本的核心任务是创建并启动一个Web服务器 (`app.listen(...)`)。
>    - 你可以把这个过程想象成：**你开了一家餐厅，并且打开了店门开始营业**。服务器就是一个在后台默默运行、时刻准备接收“订单”（请求）的程序。如果你不运行这个命令，就等于餐厅没开门。
> 2. **客户端 (Client)**:
>    - 你的**浏览器**就是客户端。
>    - 当你在浏览器地址栏输入 `http://localhost:5001` 并回车时，你就是在**发起一个请求**。
>    - 这个过程好比：**一位顾客（浏览器）走到了你的餐厅门口（`localhost:5001`），敲了敲门（发起请求），并说：“你好，我要看一下菜单（访问根目录 `/`）。”**
>
> **所以，整个流程是：**
>
> - 你必须**先运行 `node index.js`**，把餐厅（服务器）开起来。服务器启动后，就在5001端口上静静地“监听”，等待顾客上门。
> - 然后，你**再去浏览器访问**，浏览器作为顾客才能找到这家开着门的餐厅。
> - 服务器听到敲门声（接收到请求），根据你 `app.get('/')` 定义的规则，叫来服务员（执行回调函数），服务员把“菜单”（`'Hello, ...'`）递给了顾客（`res.send`)。
> - 最后，顾客（浏览器）拿到了菜单，并把它展示在了页面上。
>
> 如果你不先启动服务器，就好像顾客对着一个空无一人的、大门紧锁的店铺敲门，自然是得不到任何响应的，浏览器就会告诉你“无法访问此网站”。



**第三步：连接MongoDB数据库**

-- 创建免费的云数据库 (MongoDB Atlas)

//rwj1HTX8dEqT2RoT

-- **回到你的 VS Code**，打开 `.env` 文件。

创建一个新变量 `MONGO_URI`，然后把你刚刚复制的**完整字符串**粘贴进去。

> MONGO_URI=mongodb+srv://lmnstzz_db_user:rwj1HTX8dEqT2RoT@taskmanagerproject.ujtxmqg.mongodb.net/taskmanager?retryWrites=true&w=majority&appName=TaskManagerProject

> **第一部分：协议 (Protocol)**
>
> ```
> mongodb+srv://
> ```
>
> - `mongodb://` 是标准的连接协议。
> - 后面的 `+srv` 是一个特殊标记，意思是“SRV record”。简单来说，它告诉我们的程序：“我给你的不是一个单一服务器的地址，而是一个集群的‘域名’，请你智能地去查找这个集群里所有可用的服务器，并连接到最好的那一个。” 这使得数据库有很高的可用性，一台服务器挂了程序会自动连接到另一台。
> - `://` 是协议和后面内容的分隔符，和网址里的 `http://` 一样。
>
> **第二部分：认证信息 (Authentication)**
>
> ```
> lmnstzz_db_user:Dh1KrorzUwxX93YvA@
> ```
>
> - `lmnstzz_db_user`：你创建的**用户名**。
> - `:`：用户名和密码之间的分隔符。
> - `Dh1KrorzUwxX93YvA`：你的**密码**。
> - `@`：认证信息和服务器地址之间的分隔符。
>
> **第三部分：服务器地址 (Host)**
>
> ```
> taskmanagerproject.ujtxmag.mongodb.net
> ```
>
> - 这就是你的数据库集群在互联网上的唯一地址。我们的程序就是通过这个地址找到你的云数据库在哪里的。
>
> **第四部分：数据库名称 (Database Name) - 这就是“小优化”的关键！**
>
> ```
> /taskmanager
> ```
>
> - 这就是我建议你手动加上的部分。它明确地告诉Mongoose：“连接到上面那个服务器集群后，请**专门操作**一个叫做 `taskmanager` 的数据库。”
> - **为什么这是个优化？** 如果你不写这部分（就像MongoDB最开始提供给你的那样，在 `.net` 后面直接跟 `?`），程序通常会连接到一个默认的、名叫 `test` 的数据库。为我们的项目指定一个专有名称是个非常好的习惯。
> - **MongoDB的一个特性**：即使现在服务器上还没有 `taskmanager` 这个数据库，也没关系！当你第一次向它写入数据时（比如创建第一个用户），MongoDB会自动为你创建它。
>
> **第五部分：连接选项 (Options)**
>
> ```
> ?retryWrites=true&w=majority&appName=TaskManagerProject
> ```
>
> - `?`：表示后面跟的是一系列连接参数，和网址里的 `?` 作用一样。
> - `&`：分隔不同的参数。
> - `retryWrites=true`：这是一个可靠性设置。意思是如果一次写入操作因为网络抖动等原因失败了，驱动程序会自动重试一次。建议保持 `true`。
> - `w=majority`：这是一个数据安全设置，叫做“写关注”。`majority` 的意思是，只有当集群中“大多数”服务器都确认收到了你的写入数据后，才算写入成功。这能保证你的数据不会因为单台服务器故障而丢失。
> - `appName=TaskManagerProject`：给你当前的应用程序连接起个名字，方便你在MongoDB Atlas的管理后台里看日志和监控。
>
> **总结与回答**
>
> **问题1：这一大堆是什么意思？** 它是一张信息丰富的“地图”，告诉你的程序：
>
> > “请使用 `mongodb+srv` 协议，带着用户名 `lmnstzz_db_user` 和密码 `Dh1Krorz...`，去访问位于 `taskmanager...mongodb.net` 的服务器集群，专门操作里面一个叫 `taskmanager` 的数据库，并且在连接时启用‘写入重试’和‘大多数写入确认’等高级功能。”
>
> **问题2：为什么要加 `/taskmanager`？** 为了**明确指定我们要操作的数据库名称**，而不是使用默认的 `test` 数据库，这是一个让项目更规范、更清晰的最佳实践。



# 文档只记录到这：

![image-20250912055348502](C:\Users\lumi\AppData\Roaming\Typora\typora-user-images\image-20250912055348502.png)

也只理解到这，这个db.js的代码还没看

但是db跑通了







https://github.com/lmnst/task-manager-app.git



git remote add origin <https://github.com/lmnst/task-manager-app.git>







![image-20250926041408885](C:\Users\lumi\AppData\Roaming\Typora\typora-user-images\image-20250926041408885.png)